
from typing import TYPE_CHECKING
import uuid

from ebiose.core.engines.graph_engine.utils import GraphUtils
if TYPE_CHECKING:
    from ebiose.core.forge_cycle import ForgeCycleConfig

from ebiose.core.agent import Agent
from uuid import uuid4

# from ebiose.core.model_endpoint import ModelEndpoints


# def check_ebiose_api_key() -> bool:
#     # check user authentication 
#     api_key = ModelEndpoints.get_ebiose_api_key()
#     if api_key is None:
#         msg = "No Ebiose API key found. Please set the Ebiose API key "
#         msg += "or use the local forge cycle mode instead."
#         raise ValueError(msg)

#     return api_key == "sk-ebiose-test-key"

# def get_ecosystem() -> Ecosystem:
#     # retrieve the ecosystem object from the user
#     return 

# def start_new_forge_cycle(forge_name: str, forge_description: str, forge_cycle_config: "ForgeCycleConfig") -> tuple[str, str, any]:
#     # called at each new forge cycle
#     # returns a forge cycle id and a corresponding lite_llm_api_key generated by the server
#     lite_llm_api_key = "sk-lEdKhHOpyML94TzXOx8O-Q"
#     forge_cycle_id = "forge-cycle-id"
#     from ebiose.core.ecosystem import Ecosystem

#     ecosystem = Ecosystem.new(
#         initial_agents=[get_sample_agent()],
#     )
#     serialized_ecosystem = ecosystem.model_dump()
#     reloaded_ecosystem = Ecosystem.model_validate(serialized_ecosystem)
#     return lite_llm_api_key, forge_cycle_id, reloaded_ecosystem

def start_new_forge_cycle(
        forge_name: str, 
        forge_description: str, 
        forge_cycle_config: "ForgeCycleConfig",
) -> tuple[str, str]:
    # TODO(xabier): remove the hardcoded values
    lite_llm_api_key = "sk-ovVTleeGgW7AtmFz1988YQ"
    forge_cycle_id = "forge-cycle-id"
    return lite_llm_api_key, forge_cycle_id

def select_agents(        
        forge_cycle_id: str,
        n_selected_agents: int = 1, # should be capped to some number on the server side
) -> list[Agent]:
    
    # agent.forge_history = ["math forge", "physic forge"]
    selected_agents = [get_sample_agent() for _ in range(n_selected_agents)]
    return selected_agents


def end_forge_cycle(
        forge_cycle_id: str,
        winning_agents: list[Agent], # should create new agents server side with full metabolism
        # (must double check if the agent is already in the ecosystem.
        # if so, it should be copied with a new id and full metabolism)
        agent_metabolism_updates: dict[str, float], # {"agent-...": 0.5, ...}
        # selected_agents: list[Agent], # should update their metabolism server side         
    ):
    # called at the end of a forge cycle (or whenever an error is raised )
    # deletes the lite_llm_api_key but keep the forge cycle id
    pass

def get_spent_budget(forge_cycle_id: str) -> float:
    # returns the spent budget so far
    pass

def get_sample_agent() -> Agent:
    from pydantic import BaseModel, Field, ConfigDict

    class AgentInput(BaseModel):
        math_problem: str = Field(..., description="The mathematical word problem to solve")

    class AgentOutput(BaseModel):
        """The expected final output to the mathematical problem."""
        #   rationale: str = Field(..., description="The rationale for the solution")
        solution: int = Field(..., description="The solution to the problem.")

    shared_context_prompt = """
    Your are part of a multi-node agent that solves math problems.
    The agent has two main nodes: the solver node and the verifier node.
    The solver node solves the math problem and the verifier node verifies the solution
    given by the solver node. If it is incorrect, the verifier node provides insights
    back to the solver node so that it improves the solution.
    """

    from ebiose.core.engines.graph_engine.nodes import LLMNode

    solver_prompt = """
    Your are the Solver node. You must solve the given math problem.
    """

    solver_node = LLMNode(
        id="solver",
        name="Solver",
        purpose="solve the math problem",
        prompt=solver_prompt,
    )
    verifier_prompt = """
    You are the Verified node.
    Based on the solution provided by the Solver node,
    you must decide whether the solution is correct or not.
    If the solution is incorrect, explain why and provide insights back
    to the solver node so that it improves the solution.
    """

    verifier_node = LLMNode(
        id="verifier",
        name="Verifier",
        purpose="verify the math problem",
        prompt=verifier_prompt,
    )

    from ebiose.core.engines.graph_engine.nodes import StartNode, EndNode

    start_node = StartNode()
    end_node = EndNode()

    from ebiose.core.engines.graph_engine.graph import Graph
    from ebiose.core.engines.graph_engine.edge import Edge

    math_graph = Graph(shared_context_prompt=shared_context_prompt)

    # adding nodes
    math_graph.add_node(start_node)
    math_graph.add_node(solver_node)
    math_graph.add_node(verifier_node)
    math_graph.add_node(end_node)

    # adding edges
    # from start to solver
    math_graph.add_edge(Edge(start_node_id=start_node.id, end_node_id=solver_node.id))
    # from solver to verifier
    math_graph.add_edge(Edge(start_node_id=solver_node.id, end_node_id=verifier_node.id))
    # from verifier to end,  if the condition is correct
    math_graph.add_edge(Edge(start_node_id=verifier_node.id, end_node_id=end_node.id, condition="correct"))
    # from verifier to solver, if the condition is incorrect
    math_graph.add_edge(Edge(start_node_id=verifier_node.id, end_node_id=solver_node.id, condition="incorrect"))

    from ebiose.core.agent_engine_factory import AgentEngineFactory


    math_graph_engine = AgentEngineFactory.create_engine(
        engine_type="langgraph_engine",
        agent_id = "agent-" + str(uuid.uuid4()),
        configuration={
            "graph": math_graph.model_dump(),
            "input_model": AgentInput.model_json_schema(),
            "output_model": AgentOutput.model_json_schema(),
        },
        # input_model=AgentInput,
        # output_model=AgentOutput,
        model_endpoint_id="azure/gpt-4o-mini"
    )
    
    architect_agent = GraphUtils.get_architect_agent(model_endpoint_id="azure/gpt-4o-mini")
    crossover_agent = GraphUtils.get_crossover_agent(model_endpoint_id="azure/gpt-4o-mini")
    mutation_agent = GraphUtils.get_mutation_agent(model_endpoint_id="azure/gpt-4o-mini")

    return Agent(
        name="Math Agent",
        description="An agent that solves math problems",
        agent_engine=math_graph_engine,
        id = math_graph_engine.agent_id,
        architect_agent=architect_agent,
        genetic_operator_agent=mutation_agent,

    )